import configparser
import datetime
import tkinter as tk
from tkinter import filedialog, Scrollbar
from pytubefix import Playlist, YouTube
from pytube.exceptions import RegexMatchError
import os
import re
import threading

# Getting user configs (just the directory for now) and download history
config = configparser.ConfigParser()
config_file = 'config.ini'
history_file = 'history.ini'

if not os.path.exists(config_file):
    config['DEFAULT'] = {'output_path': os.path.join(os.path.expanduser('~'), 'Downloads')}
    with open(config_file, 'w') as f:
        config.write(f)

config.read(config_file)
output_path = config['DEFAULT']['output_path']

window_width = 600
window_height = 400
bitrates = ["64kbps", "128kbps", "192kbps", "256kbps", "320kbps"]

def encode_to_ascii(text):
    try:
        return text.encode('ascii', 'replace').decode('ascii')
    except UnicodeEncodeError:
        return ''.join(['ï¿½' if ord(char) > 127 else char for char in text])


def add_download_to_history(history_format):
    config.read(history_file)

    if 'DownloadHistory' not in config:
        config['DownloadHistory'] = {}

    download_count = len([key for key in config['DownloadHistory'] if key.startswith('download_')])
    next_download_number = download_count + 1

    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    ascii_format = encode_to_ascii(history_format)
    config['DownloadHistory'][f'download_{next_download_number}'] = f'at {timestamp}: {ascii_format}'

    with open(history_file, 'w') as configfile:
        config.write(configfile)

def fix_filename(filename):
    return re.sub(r'[<>:"/\\|?*]', '', filename)

def download_youtube_video_as_mp3(youtube_url, output_path, text_widget, bitrate):
    def download_thread():
        try:
            yt = YouTube(youtube_url)

            title = yt.title
            fixed_title = fix_filename(title)

            # Bitrate stuff
            audio_streams = yt.streams.filter(only_audio=True)
            desired_bitrate_int = int(bitrate.replace('kbps', ''))
            target_stream = None
            closest_bitrate = 0

            for stream in audio_streams:
                stream_bitrate_int = int(stream.abr.replace('kbps', ''))
                if stream_bitrate_int <= desired_bitrate_int and stream_bitrate_int > closest_bitrate:
                    target_stream = stream
                    closest_bitrate = stream_bitrate_int
            
            if not target_stream:
                text_widget.insert(tk.END, f"No suitable audio stream found for {youtube_url}. Available bitrates: {[stream.abr for stream in audio_streams]}\n\n")
                text_widget.see(tk.END)
                return

            mp4_file_path = target_stream.download(output_path=output_path)

            mp3_file_path = os.path.join(output_path, f"{fixed_title}.mp3")

            # Ensures unique file names
            if os.path.exists(mp3_file_path):
                base_name, ext = os.path.splitext(mp3_file_path)
                counter = 1
                while os.path.exists(mp3_file_path):
                    mp3_file_path = f"{base_name}_{counter}{ext}"
                    counter += 1

            os.rename(mp4_file_path, mp3_file_path)
            text_to_add = f"Successfully Downloaded {title} at {mp3_file_path}\n\n"
            add_download_to_history(text_to_add)
            text_widget.insert(tk.END, text_to_add)
        except RegexMatchError:
            text_widget.insert(tk.END, f"Error downloading {youtube_url}: Invalid YouTube Link\n\n")
            text_widget.see(tk.END)
        except Exception as e:
            text_widget.insert(tk.END, f"Error downloading {youtube_url}: {str(e)}\n\n")
            text_widget.see(tk.END)

    current_thread = threading.Thread(target=download_thread)
    current_thread.start()

#TODO add it being able to download a single video here if it isn't a playlist
def download_playlist_as_mp3(playlist_url, output_path, text_widget, bitrate):
    def download_thread():
        try:
            pl = Playlist(playlist_url)
            print(f"found the Playlist with {pl.length} videos") #TODO remove this or something debugging

            if (pl.length == 0):
                raise ValueError("Invalid YouTube Playlist Link")

            for url in pl.video_urls:
                download_youtube_video_as_mp3(url, output_path, text_widget, bitrate)
        except ValueError as ve:
            text_widget.insert(tk.END, f"Error downloading {playlist_url}: {ve}\n\n")
            text_widget.see(tk.END)
        except Exception as e:
            if str(e) == "'sidebar'":
                text_widget.insert(tk.END, f"Error downloading {playlist_url}: Unable to download Youtube Autogenerated Mixes\n\n")
            else:
                text_widget.insert(tk.END, f"Error downloading {playlist_url}: {str(e)}\n\n")
            text_widget.see(tk.END)

    current_thread = threading.Thread(target=download_thread)
    current_thread.start()

def set_window_dimensions(window):
    screen_width = window.winfo_screenwidth()
    screen_height = window.winfo_screenheight()
    x = (screen_width // 2) - (window_width // 2)
    y = (screen_height // 2) - (window_height // 2)
    window.geometry(f"{window_width}x{window_height}+{x}+{y}")

def on_mp3_click():
    for widget in main_menu.winfo_children():
        widget.destroy()

    main_menu.title("Youtube MP3 Downloader - Video")

    enter_video_label = tk.Label(main_menu, text="Enter the Video Link:")
    enter_video_label.pack(pady=10)

    selection_frame = tk.Frame(main_menu)
    selection_frame.pack(pady=10)

    back_button = tk.Button(selection_frame, text="Back", command=on_back_click)
    back_button.pack(side=tk.LEFT, padx=5)

    selected_bitrate = tk.StringVar(value=bitrates[0])
    bitrate_dropdown = tk.OptionMenu(selection_frame, selected_bitrate, *bitrates)
    bitrate_dropdown.pack(side=tk.LEFT, padx=5)

    video_link_entry = tk.Entry(selection_frame, width=50)
    video_link_entry.pack(side=tk.LEFT, padx=5)

    download_button = tk.Button(selection_frame, text="Download MP3", 
                                command=lambda: download_youtube_video_as_mp3(video_link_entry.get(), output_path, downloads_text, selected_bitrate.get()))
    download_button.pack(side=tk.LEFT, padx=5)

    downloads_text = tk.Text(main_menu, wrap=tk.WORD, height=15, width=70)
    downloads_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, pady=20, padx=10)

    scrollbar = Scrollbar(main_menu, command=downloads_text.yview)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    downloads_text.config(yscrollcommand=scrollbar.set)

    video_link_entry.bind("<Return>", lambda event: download_youtube_video_as_mp3(video_link_entry.get(), output_path, downloads_text))

def on_playlist_mp3_click():
    for widget in main_menu.winfo_children():
        widget.destroy()

    main_menu.title("Youtube MP3 Downloader - Playlist")

    enter_playlist_label = tk.Label(main_menu, text="Enter the Playlist Link:")
    enter_playlist_label.pack(pady=10)

    selection_frame = tk.Frame(main_menu)
    selection_frame.pack(pady=10)

    back_button = tk.Button(selection_frame, text="Back", command=on_back_click)
    back_button.pack(side=tk.LEFT, padx=5)

    selected_bitrate = tk.StringVar(value=bitrates[0])
    bitrate_dropdown = tk.OptionMenu(selection_frame, selected_bitrate, *bitrates)
    bitrate_dropdown.pack(side=tk.LEFT, padx=5)

    playlist_link_entry = tk.Entry(selection_frame, width=50)
    playlist_link_entry.pack(side=tk.LEFT, padx=5)

    download_button = tk.Button(selection_frame, text="Download Playlist MP3", 
                                command=lambda: download_playlist_as_mp3(playlist_link_entry.get(), output_path, downloads_text, selected_bitrate.get()))
    download_button.pack(side=tk.LEFT, padx=5)

    downloads_text = tk.Text(main_menu, wrap=tk.WORD, height=15, width=70)
    downloads_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, pady=20, padx=10)

    scrollbar = Scrollbar(main_menu, command=downloads_text.yview)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    downloads_text.config(yscrollcommand=scrollbar.set)

    playlist_link_entry.bind("<Return>", lambda event: download_playlist_as_mp3(playlist_link_entry.get(), output_path, downloads_text))


def on_exit_click():
    main_menu.destroy()

def on_back_click():
    for widget in main_menu.winfo_children():
        widget.destroy()
    main_menu.title("Youtube MP3 Downloader")
    live_path.set("Current Path: " + output_path)

    padding = tk.Frame(main_menu, height=20)
    main_menu.protocol("WM_DELETE_WINDOW", on_exit_click)
    video_mp3_button = tk.Button(main_menu, text="Download Video MP3", command=on_mp3_click)
    playlist_mp3_button = tk.Button(main_menu, text="Download Playlist MP3", command=on_playlist_mp3_click)
    history_button = tk.Button(main_menu,text="View Download History", command=on_history_click)
    exit_button = tk.Button(main_menu, text="Exit", command=on_exit_click)
    select_directory_button = tk.Button(main_menu, text="Select Path", command=on_directory_select_click)
    current_directory = tk.Label(main_menu, textvariable=live_path)

    video_mp3_button.pack(pady=20)
    playlist_mp3_button.pack(pady=20)
    history_button.pack(pady=20)

    padding.pack()
    select_directory_button.pack()
    current_directory.pack()

    padding.pack()
    exit_button.pack(pady=20)

def on_directory_select_click():
    global output_path
    global live_path

    selected_path = filedialog.askdirectory()
    if selected_path:
        output_path = selected_path
        live_path.set("Current Path: " + output_path)
        save_output_path(output_path)


def on_history_click():
    for widget in main_menu.winfo_children():
        widget.destroy()

    main_menu.title("Youtube MP3 Downloader - History")

    back_button = tk.Button(main_menu, text="Back", command=on_back_click)
    back_button.pack(pady=5)

    downloads_text = tk.Text(main_menu, wrap=tk.WORD, height=15, width=70)
    downloads_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, pady=20, padx=10)

    scrollbar = Scrollbar(main_menu, command=downloads_text.yview)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    downloads_text.config(yscrollcommand=scrollbar.set)

    config.read(history_file)
    if 'DownloadHistory' in config:
        downloads = config['DownloadHistory']

    if len(downloads) > 0:
        for key in downloads:
            downloads_text.insert(tk.END, f"{downloads[key]}\n\n")
    else:
        downloads_text.insert(tk.END, "No history available.\n\n")

    downloads_text.see(tk.END)


# Saves the directory output path to the config.ini file
def save_output_path(path):
    config['DEFAULT']['output_path'] = path
    with open(config_file, 'w') as f:
        config.write(f)


def main():
    global main_menu
    global live_path
    main_menu = tk.Tk()
    main_menu.title("Youtube MP3 Downloader")
    live_path = tk.StringVar()
    live_path.set("Current Path: " + output_path)

    set_window_dimensions(main_menu)

    padding = tk.Frame(main_menu, height=20)
    main_menu.protocol("WM_DELETE_WINDOW", on_exit_click)
    video_mp3_button = tk.Button(main_menu, text="Download Video MP3", command=on_mp3_click)
    playlist_mp3_button = tk.Button(main_menu, text="Download Playlist MP3", command=on_playlist_mp3_click)
    history_button = tk.Button(main_menu,text="View Download History", command=on_history_click)
    exit_button = tk.Button(main_menu, text="Exit", command=on_exit_click)
    select_directory_button = tk.Button(main_menu, text="Select Path", command=on_directory_select_click)
    current_directory = tk.Label(main_menu, textvariable=live_path)

    video_mp3_button.pack(pady=20)
    playlist_mp3_button.pack(pady=20)
    history_button.pack(pady=20)

    padding.pack()
    select_directory_button.pack()
    current_directory.pack()
    
    padding.pack()
    exit_button.pack(pady=20)

    main_menu.mainloop()

if __name__ == "__main__":
    main()
